
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Rendu front, action ! Découvrez les différents modes de rendu avec Next.js</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="docs"
                  title="Rendu front, action ! Découvrez les différents modes de rendu avec Next.js"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Initialisation du codelab" duration="5">
        <p>Prérequis :</p>
<ul>
<li><a href="https://git-scm.com/" target="_blank">Git</a></li>
<li><a href="https://nodejs.org/" target="_blank">Node / npm</a> (version 18 minimum)</li>
<li><a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> (ou tout autre IDE JS)</li>
</ul>
<aside class="warning"><p>Il est impératif d&#39;avoir une version 18 minimale de Node.js car elle est un prérequis pour les React Server Components que nous verrons dans ce codelab.</p>
</aside>
<p>Pour ce codelab nous utiliserons deux repositories :</p>
<ul>
<li>L&#39;un qui servira pour l&#39;exercice sur le client side rendering</li>
<li>L&#39;autre servira pour les exercices suivants basés sur Next.js</li>
</ul>
<p>Installer le projet pour l&#39;exercice sur le client side rendering, en se positionnant sur la branche <code>start</code> :</p>
<pre><code language="language-bash" class="language-bash">git clone --branch start https://github.com/Codelab-DevFest-2023/codelab-devfest2023-csr.git
cd codelab-devfest2023-csr
npm install
</code></pre>
<p>Lancer la commande <code>npm run dev</code> et vérifier qu&#39;on a bien une application qui s&#39;affiche sur l&#39;url <code>http://localhost:3000</code>.</p>
<p>Puis installer le projet pour les exercices avec Next.js :</p>
<pre><code language="language-bash" class="language-bash">git clone --branch start https://github.com/Codelab-DevFest-2023/codelab-devfest2023-next.git
cd codelab-devfest2023-next
npm install
</code></pre>
<p>Lancer la commande <code>npm run dev</code> et vérifier qu&#39;on a bien une application qui s&#39;affiche sur l&#39;url <code>http://localhost:3000</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Client Side Rendering" duration="20">
        <p>Dans cette première partie, nous allons développer une application en Client Side Rendering s&#39;appuyant sur Vite.js, React et Tailwind. Nous n&#39;utiliserons donc pas Next.js dans cet exercice, mais il permettra de se rendre compte des différences entre le client side rendering et les autres modes de rendu que nous verrons plus tard.</p>
<aside class="special"><p>Pour se concentrer sur ce qui est spécifique au client side rendering, certains composants vous sont déjà fournis dans le repository : carte d&#39;un film, méthodes de fetch, composant de layout, etc...</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Pour commencer, nous allons créer un écran affichant la liste des films. Nous avons donc besoin de créer :</p>
<ul>
<li>Un hook <code>useMovies</code> qui permet de charger la liste des films</li>
<li>Un composant <code>MoviesList</code> qui affiche la liste des films</li>
<li>Une route <code>/movies</code> associée au composant <code>MoviesList</code></li>
</ul>
<p>Dans le répertoire <code>/src/hooks</code> du projet, créons le fichier <code>useMovies.ts</code>. Ce hook s&#39;appuie sur la librairie React Query pour gérer du cache.</p>
<pre><code language="language-ts" class="language-ts">import { useQuery } from &#39;@tanstack/react-query&#39;;

export default useMovies = () =&gt; {
  return useQuery({});
};
</code></pre>
<p>Puis dans le répertoire <code>/src/pages</code> nous allons créer le fichier <code>MoviesListPage.tsx</code> qui utilise le hook <code>useMovies</code> pour récupérer les films puis parcourt les films pour afficher une card pour chaque film. Un loader est affiché pendant le chargement des films.</p>
<pre><code language="language-ts" class="language-ts">TODO;
</code></pre>
<p>Enfin nous allons créer une route <code>/movies</code> dans le fichier <code>/src/router.ts</code>. Cette route est associée au composant <code>MoviesListPage</code>.</p>
<pre><code language="language-ts" class="language-ts">TODO;
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite nous allons créer un écran affichant le détail de chaque film. Nous avons besoin de créer :</p>
<ul>
<li>Un hook <code>useMovie</code> qui permet de charger le détail du film</li>
<li>Un composant <code>MovieDetailsPage</code> qui définit la page de détail d&#39;un film</li>
<li>Une route <code>/movies/:id</code> qui définit des routes pour le</li>
</ul>
<p>Dans le répertoire <code>/src/hooks</code> du projet, créons le fichier <code>useMovie.ts</code> avec le contenu suivant :</p>
<pre><code language="language-ts" class="language-ts">import { useQuery } from &#34;@tanstack/react-query&#34;;

export default useMovie = () =&gt; {
  return useQuery({...});
};
</code></pre>
<p>Puis dans le répertoire <code>/src/pages</code> nous allons créer le fichier <code>MovieDetailsPage.tsx</code> qui utilise le hook <code>useMovie</code> pour récupérer le détail du film puis afficher les informations. Un loader est affiché pendant le chargement du film.</p>
<pre><code language="language-ts" class="language-ts">TODO;
</code></pre>
<p>Enfin nous allons créer une route <code>/movies/:id</code> dans le fichier <code>/src/router.ts</code>. Cette route est associée au composant <code>MovieDetailsPage</code>.</p>
<pre><code language="language-ts" class="language-ts">TODO;
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement.</p>
<h2 is-upgraded>Analysons cette application</h2>
<p>Ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>
<p>Enfin affichons le code source de la page pour constater que cette page n&#39;est pas très &#34;SEO friendly&#34; !</p>


      </google-codelab-step>
    
      <google-codelab-step label="Server Side Rendering" duration="35">
        <p>Dans cette deuxième partie, nous allons développer une application en Server Side Rendering s&#39;appuyant sur Next.js et Tailwind.</p>
<aside class="special"><p>Pour se concentrer sur ce qui est spécifique au server side rendering, certains composants vous sont déjà fournis dans le repository : carte d&#39;un film, méthodes de fetch, composant de layout, etc...</p>
</aside>
<aside class="warning"><p>Cet exercice utilisera le routage <strong>pages</strong> (Next.js &lt; 13).</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Nous allons créer un écran affichant la liste des films. Nous aurons besoin de créer la page d&#39;affichage de la liste des films.</p>
<p>Dans le répertoire <code>/src/pages/ssr</code> du projet, modifions le fichier <code>index.tsx</code>.</p>
<p>Nous allons utiliser la méthode <code>getServerSideProps</code> qui permet de récupérer des données côté serveur. Ici, la méthode <code>getServerSideProps</code> récupère des données l&#39;API et les transmet en tant que propriété <code>movies</code> à la page <code>SSRPage</code>. Ces données sont disponibles côté serveur lors de la demande de la page.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSRPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  // ...
};

export const getServerSideProps: GetServerSideProps&lt;{
  movies: Movie[];
}&gt; = async () =&gt; {
  const { results: movies } = await getMovies();
  return { props: { movies } };
};

export default SSRPage;
</code></pre>
<aside class="special"><p>Vous pouvez définir <strong>getServerSideProps</strong> pour chaque page individuelle, ce qui permet d&#39;obtenir des données spécifiques à cette page.</p>
</aside>
<p>Il ne reste plus qu&#39;a finir de construire notre page, en affichant la liste des films :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

const SSRPage = ({
  movies,
  total,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  const pathname = &#39;/ssr&#39;;
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Server Side Rendering&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
        &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
          {movies?.map((movie: Movie) =&gt; (
            &lt;li key={movie.id}&gt;
              &lt;MovieCard movie={movie} pathname={pathname} /&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        {movies.length &lt; 1 &amp;&amp; (
          &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
        )}
      &lt;/main&gt;
    &lt;/&gt;
  );
};
// ...
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/ssr</code>.</p>
<h2 is-upgraded>Optimisations des images</h2>
<p>Afin d&#39;optimiser l&#39;affichage des images sur l&#39;application. Nous allons utiliser le composant Image de Next.js.</p>
<p>Le composant Image est conçu pour améliorer les performances et l&#39;expérience utilisateur en matière de gestion des images, en simplifiant l&#39;optimisation, le chargement asynchrone et l&#39;adaptation des images aux besoins de l&#39;utilisateur, tout en réduisant la charge de travail pour les développeurs.</p>
<p>Il offre plusieurs avantages par rapport à l&#39;utilisation d&#39;une balise HTML <code>img</code> standard</p>
<p>Dans le répertoire <code>/src/components/movie/card</code> du projet, ouvrons le fichier <code>MovieCard.tsx</code>.</p>
<p>Remplaçons le composant <code>img</code> par un composant <code>Image</code> :</p>
<pre><code language="language-tsx" class="language-tsx">import Image from &#39;next/image&#39;;

// ...

&lt;Image
  src={posterUrl}
  alt={movie.title}
  className=&#34;rounded-t-lg aspect-[2/3] object-cover&#34;
  height={750}
  width={500}
  sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
  priority
/&gt;;

// ...
</code></pre>
<h2 is-upgraded>Recherche de films</h2>
<p>Nous allons créer un composant qui nous permettra de rechercher un film. Dans le cas d&#39;une recherche côté serveur, la recherche de l&#39;utilisateur sera envoyé dans l&#39;url de la page en paramètre <code>http://localhost:3000/ssr?query=xxxx</code>.</p>
<p>Dans le répertoire <code>/src/components/search</code> du projet, ouvrons le fichier <code>SearchBox.tsx</code>.</p>
<aside class="warning"><p>Ce composant sera composé de plusieurs hooks React et devra s&#39;exécuter côté client.Pour cela, il est impératif de spécifier <strong>&#39;use client&#39;</strong> dans le fichier.</p>
</aside>
<pre><code language="language-tsx" class="language-tsx">&#39;use client&#39;; // Composant client
import { QUERY_PARAMS } from &#39;@/constants&#39;;
import { usePathname, useRouter, useSearchParams } from &#39;next/navigation&#39;;
import { ChangeEvent, useState } from &#39;react&#39;;

const SearchBox = () =&gt; {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const [searchValue, setSearchValue] = useState&lt;string | undefined&gt;();

  const handleSearchChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const currentPathname = pathname ?? &#39;/&#39;;
    const value = event.target.value;
    setSearchValue(value);

    const queryParams = new URLSearchParams();
    queryParams.append(QUERY_PARAMS.QUERY, encodeURI(value));

    if (value.length &gt; 3) {
      router.push(`${currentPathname}?${queryParams.toString()}`);
    }

    if (value.length &lt;= 2 &amp;&amp; searchParams?.get(QUERY_PARAMS.QUERY)) {
      router.push(currentPathname);
    }
  };

  return (
    &lt;input
      type=&#34;text&#34;
      className=&#34;text-xl py-3 px-6 bg-white rounded-full w-fit focus-visible:ring-primary focus-visible:ring-offset-primary&#34;
      placeholder=&#34;Recherche ...&#34;
      value={searchValue}
      onChange={handleSearchChange}
    /&gt;
  );
};

export default SearchBox;
</code></pre>
<p>Avant le rendu, la page analysera l&#39;url afin :</p>
<ul>
<li>D&#39;appeler la route <code>search/movie</code> en cas de presence du paramètre <code>query</code></li>
<li>D&#39;appeler la route <code>movie/popular</code> en cas d&#39;absence du paramètre <code>query</code></li>
</ul>
<p>Il faut alors modifier la méthode <code>getServerSideProps</code> de la page <code>/src/pages/ssr/index.tsx</code> afin de gérer ces deux cas :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { transformParsedUrlQuery } from &#39;@/helpers&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

// ...

export const getServerSideProps: GetServerSideProps&lt;{
  movies: Movie[];
}&gt; = async ({ query: params }) =&gt; {
  const searchParams = transformParsedUrlQuery(params);
  const { results: movies } = await fetchMovies(searchParams);
  return { props: { movies } };
};
</code></pre>
<p>Il ne reste plus qu&#39;a ajouter le composant <code>Search.tsx</code></p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import SearchBox from &#39;@/components/search/SearchBox&#39;;
import { transformParsedUrlQuery } from &#39;@/helpers&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

// ...
&lt;&gt;
  &lt;Head&gt;
    &lt;title&gt;Server Side Rendering&lt;/title&gt;
  &lt;/Head&gt;
  &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
    &lt;SearchBox /&gt;
    &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
      {movies?.map((movie: Movie) =&gt; (
        &lt;li key={movie.id}&gt;
          &lt;MovieCard movie={movie} pathname={pathname} /&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
    {movies.length &lt; 1 &amp;&amp; (
      &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
    )}
  &lt;/main&gt;
&lt;/&gt;;
// ...
</code></pre>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite, nous allons créer un écran affichant le détail de chaque film. Nous aurons besoin de créer la page d&#39;affichage des détails d&#39;un film.</p>
<p>Dans le répertoire <code>/src/pages/ssr</code> du projet, modifions le fichier <code>[id].tsx</code>.</p>
<p>Nous allons réutiliser la méthode <code>getServerSideProps</code> pour récupérer les données concernant le film passé en paramètre.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSRMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  // ...
};

export const getServerSideProps: GetServerSideProps&lt;{
  movie: Movie;
}&gt; = async ({ params }) =&gt; {
  if (params?.id) {
    const id = Number(params.id);
    const movie = await getMovieDetails(id);
    return { props: { movie } };
  } else {
    throw new Error(&#39;Missing id parameter&#39;);
  }
};

export default SSRMovieDetailsPage;
</code></pre>
<p>Il ne reste plus qu&#39;a finir de construire notre page, En affichant :</p>
<ul>
<li>L&#39;affiche du film</li>
<li>Le titre du film</li>
<li>Le synopsis du film</li>
<li>La note du film</li>
</ul>
<pre><code language="language-tsx" class="language-tsx">import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

const SSRMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main&gt;
      &lt;Head&gt;
        &lt;title&gt;Server Side Rendering&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div className=&#34;flex md:flex-row flex-col&#34;&gt;
        &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
          &lt;Image
            src={posterUrl}
            alt={movie.title}
            className=&#34;aspect-[2/3] object-cover h-full&#34;
            height={750}
            width={500}
            sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
            priority
          /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;description relative w-full&#34;&gt;
          &lt;Image
            className=&#34;block z-0 object-cover brightness-50&#34;
            alt={movie.title}
            src={backdropPathUrl}
            fill
            priority
          /&gt;
          &lt;div className=&#34;relative flex flex-col&#34;&gt;
            &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
              &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
              &lt;div className=&#34;flex gap-2&#34;&gt;
                {movie.genres.map((genre) =&gt; {
                  return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
                })}
              &lt;/div&gt;
              &lt;p&gt;{movie.tagline}&lt;/p&gt;
              &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
              &lt;div className=&#34;flex items-center gap-3&#34;&gt;
                &lt;Note note={movie.vote_average} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

// ...
</code></pre>
<h2 is-upgraded>Gestion de favoris</h2>
<p>Maintenant, mettons en place une gestion des favoris en utilisant le <code>localstorage</code> du navigateur. Nous allons utiliser un nouveau composant <code>Like</code>.</p>
<aside class="warning"><p>Ce composant aura besoin d&#39;accèder au <strong>localstorage</strong> du navigateur. Pour cela, il doit s&#39;exécuter côté client (<strong>&#39;use client&#39;</strong>).</p>
</aside>
<p>Dans le répertoire <code>/src/components/like</code> du projet, ouvrons le fichier <code>Like.tsx</code>.</p>
<pre><code language="language-tsx" class="language-tsx">&#39;use client&#39;;
import { useEffect, useState } from &#39;react&#39;;
import &#39;./like.module.css&#39;;

interface Props {
  id: number;
}

const Like = ({ id }: Props) =&gt; {
  const [filled, setFilled] = useState(false);

  useEffect(() =&gt; {
    const favorites = localStorage.getItem(&#39;favorites&#39;);
    if (favorites) {
      const isFind = JSON.parse(favorites).find(
        (element: { id: number }) =&gt; element.id === id
      );
      if (isFind) {
        setFilled(true);
      }
    } else {
      setFilled(false);
    }
  }, [id]);

  const handleClick = () =&gt; {
    const favorites = localStorage.getItem(&#39;favorites&#39;);
    if (favorites) {
      const favoritesList = JSON.parse(favorites);

      const filterFav = favoritesList.filter(
        (fav: { id: number }) =&gt; fav.id !== id
      );

      if (filterFav.length === favoritesList.length) {
        setFilled(true);
        favoritesList.push({ id: id });
        localStorage.setItem(&#39;favorites&#39;, JSON.stringify(favoritesList));
      } else {
        setFilled(false);
        localStorage.setItem(&#39;favorites&#39;, JSON.stringify(filterFav));
      }
    } else {
      setFilled(true);
      localStorage.setItem(&#39;favorites&#39;, JSON.stringify([{ id: id }]));
    }
  };

  return (
    &lt;button
      className={`heart-button ${filled ? &#39;filled&#39; : &#39;&#39;}`}
      onClick={handleClick}
    &gt;
      &lt;svg className=&#34;heart-icon&#34; viewBox=&#34;0 0 26 26&#34;&gt;
        &lt;path d=&#34;M12 21.35l-1.45-1.32C5.4 16.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C15.09 3.81 16.76 3 18.5 3 21.58 3 24 5.42 24 8.5c0 3.78-3.4 7.86-8.55 11.54L12 21.35z&#34; /&gt;
      &lt;/svg&gt;
    &lt;/button&gt;
  );
};

export default Like;
</code></pre>
<p>Il ne reste plus qu&#39;a rajouter ce nouveau composant dans la page SSR (<code>/src/pages/ssr/[id].tsx</code>) :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

// ...
&lt;div className=&#34;relative flex flex-col&#34;&gt;
  &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
    &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
    &lt;div className=&#34;flex gap-2&#34;&gt;
      {movie.genres.map((genre) =&gt; {
        return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
      })}
    &lt;/div&gt;
    &lt;p&gt;{movie.tagline}&lt;/p&gt;
    &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
    &lt;div className=&#34;flex items-center gap-3&#34;&gt;
      &lt;Note note={movie.vote_average} /&gt;
      &lt;Like id={movie.id} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;;
// ...
</code></pre>
<h2 is-upgraded>Observons ce qui se passe</h2>
<p>Ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Static Site Generation" duration="10">
        <aside class="special"><p>Si vous n&#39;avez pas eu le temps de finir l&#39;étape précédente, vous pouvez faire un checkout de la branche &#34;ssr-end&#34; pour débuter cette étape : <code>git checkout -f ssr-end</code></p>
</aside>
<p>Dans cette troisième partie, nous allons développer la même application que précédement mais en Static Site Generation en s&#39;appuyant sur Next.js et Tailwind.</p>
<aside class="warning"><p>Cet exercice utilisera le routage <strong>pages</strong> (Next.js &lt; 13).</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Comme dans l&#39;exercice précédent, nous aurons besoin de créer la page d&#39;affichage de la liste des films.</p>
<p>Dans le répertoire <code>/src/pages/ssg</code> du projet, modifions le fichier <code>index.tsx</code>.</p>
<p>Nous allons utiliser la méthode <code>getStaticProps</code> qui permet de générer des pages statiques lors de la construction de l&#39;application, en précalculant les données à afficher sur ces pages.</p>
<p>Ici, la méthode <code>getStaticProps</code> récupère des données l&#39;API et les transmet en tant que propriété <code>movies</code> à la page <code>SSRPage</code>. Les données sont précalculées au moment de la construction de l&#39;application et servies en tant que pages statiques.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovies } from &#39;@/services/movie.service&#39;;
import { GetStaticProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSGPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  // ...
};

export const getStaticProps: GetStaticProps&lt;{
  movies: Movie[];
}&gt; = async () =&gt; {
  const { results: movies } = await getMovies();
  return { props: { movies } };
};

export default SSGPage;
</code></pre>
<p>Il ne reste plus qu&#39;a finir de construire notre page, en affichant la liste des films :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovies } from &#39;@/services/movie.service&#39;;
import { GetStaticProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

const SSGPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  const pathname = &#39;/ssg&#39;;
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Static Site Generation&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
        &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
          {movies?.map((movie: Movie) =&gt; (
            &lt;li key={movie.id}&gt;
              &lt;MovieCard movie={movie} pathname={pathname} /&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        {movies.length &lt; 1 &amp;&amp; (
          &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
        )}
      &lt;/main&gt;
    &lt;/&gt;
  );
};

// ...
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/ssg</code>.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite, nous allons créer un écran affichant le détail de chaque film.</p>
<p>Dans le répertoire <code>/src/pages/ssg</code> du projet, modifions le fichier <code>[id].tsx</code>.</p>
<p>Nous allons réutiliser la méthode <code>getStaticProps</code> pour récupérer les données concernant le film passé en paramètre.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetStaticProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSGMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  // ...
};

export const getStaticProps: GetStaticProps&lt;{
  movie: Movie;
}&gt; = async ({ params }) =&gt; {
  if (params?.id) {
    const id = Number(params.id);
    const movie = await getMovieDetails(id);
    return { props: { movie } };
  } else {
    throw new Error(&#39;Missing id parameter&#39;);
  }
};

export default SSGMovieDetailsPage;
</code></pre>
<p>Nous devons aussi utiliser la méthode <code>getStaticPaths</code> afin de générer les chemins (URL) pour les pages dynamiques lors de la génération statique.</p>
<aside class="special"><p><strong>getStaticPath</strong> est souvent utilisée avec <strong>getStaticProps</strong> pour générer des pages dynamiques précalculées, où les chemins sont basés sur des données provenant d&#39;une source externe, comme une API ou une base de données.</p>
</aside>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails, getMovies } from &#39;@/services/movie.service&#39;;
import {
  GetStaticPaths,
  GetStaticProps,
  InferGetServerSidePropsType,
} from &#39;next&#39;;

const SSGMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  // ...
};

export const getStaticProps: GetStaticProps&lt;{
  movie: Movie;
}&gt; = async ({ params }) =&gt; {
  if (params?.id) {
    const id = Number(params.id);
    const movie = await getMovieDetails(id);
    return { props: { movie } };
  } else {
    throw new Error(&#39;Missing id parameter&#39;);
  }
};

export const getStaticPaths: GetStaticPaths = async () =&gt; {
  const { results: movies } = await getMovies();
  return {
    paths: movies.map((movie) =&gt; `/ssg/${movie.id}`),
    fallback: false,
  };
};

export default SSGMovieDetailsPage;
</code></pre>
<p>Il ne reste plus qu&#39;a finir de construire notre page :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails, getMovies } from &#39;@/services/movie.service&#39;;
import {
  GetStaticPaths,
  GetStaticProps,
  InferGetServerSidePropsType,
} from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

const SSGMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main&gt;
      &lt;Head&gt;
        &lt;title&gt;Static Site Generation&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div className=&#34;flex md:flex-row flex-col&#34;&gt;
        &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
          &lt;Image
            src={posterUrl}
            alt={movie.title}
            className=&#34;aspect-[2/3] object-cover h-full&#34;
            height={750}
            width={500}
            sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
            priority
          /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;description relative w-full&#34;&gt;
          &lt;Image
            className=&#34;block z-0 object-cover brightness-50&#34;
            alt={movie.title}
            src={backdropPathUrl}
            fill
            priority
          /&gt;
          &lt;div className=&#34;relative flex flex-col&#34;&gt;
            &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
              &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
              &lt;div className=&#34;flex gap-2&#34;&gt;
                {movie.genres.map((genre) =&gt; {
                  return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
                })}
              &lt;/div&gt;
              &lt;p&gt;{movie.tagline}&lt;/p&gt;
              &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
              &lt;div className=&#34;flex items-center gap-3&#34;&gt;
                &lt;Note note={movie.vote_average} /&gt;
                &lt;Like id={movie.id} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

// ...
</code></pre>
<h2 is-upgraded>Observons ce qui se passe</h2>
<p>Ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="React Server Components" duration="25">
        <aside class="special"><p>Si vous n&#39;avez pas eu le temps de finir l&#39;étape précédente, vous pouvez faire un checkout de la branche &#34;ssg-end&#34; pour débuter cette étape : <code>git checkout -f ssg-end</code></p>
</aside>
<p>Dans cette quatrième et dernière partie, nous allons développer la même application que précédement mais en utilisant les React Server Components, toujours en s&#39;appuyant sur Next.js et Tailwind.</p>
<aside class="warning"><p>Cet exercice utilisera le routage <strong>app</strong> (Next.js &gt; 13).</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Comme dans l&#39;exercice précédent, nous aurons besoin de créer la page d&#39;affichage de la liste des films.</p>
<p>Dans le répertoire <code>/src/app/rsc</code> du projet, modifions le fichier <code>page.tsx</code>.</p>
<p>Nous n&#39;avons plus besoin d&#39;utiliser une méthode spécifique pour récupérer les données. nous pouvons directement faire un appel API dans notre composant serveur :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import SearchBox from &#39;@/components/search/SearchBox&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;

export const revalidate = 0;

interface Props {
  searchParams: { [key: string]: string | string[] | undefined };
}

const RSCPage = async ({ searchParams }: Props) =&gt; {
  const pathname = &#39;/rsc&#39;;
  const { results: movies } = await fetchMovies(searchParams);

  return (
    &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
      &lt;SearchBox /&gt;
      &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
        {movies?.map((movie: Movie) =&gt; (
          &lt;li key={movie.id}&gt;
            &lt;MovieCard movie={movie} pathname={pathname} /&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      {movies.length &lt; 1 &amp;&amp; (
        &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
      )}
    &lt;/main&gt;
  );
};

export default RSCPage;
</code></pre>
<aside class="special"><p>Le code <strong>export const revalidate = 0;</strong> est un mécanisme qui permet de mettre en cache les données générées côté serveur (SSR) pendant une période spécifiée. En mettant revalidate à zéro (0), cela signifie que les données seront générées à chaque demande sans mise en cache ni expiration. </p>
</aside>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/rsc</code>.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite, nous allons créer un écran affichant le détail de chaque film.</p>
<p>Dans le répertoire <code>/src/app/rsc/[id]</code> du projet, modifions le fichier <code>page.tsx</code>.</p>
<p>Comme précédement, nous pouvons directement faire un appel API dans notre composant serveur :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import Image from &#39;next/image&#39;;

const RSCMovieDetailsPage = async ({ params }: { params: { id: number } }) =&gt; {
  const movie = await getMovieDetails(params.id);

  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main className=&#34;flex md:flex-row flex-col&#34;&gt;
      &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
        &lt;Image
          src={posterUrl}
          alt={movie.title}
          className=&#34;aspect-[2/3] object-cover h-full&#34;
          height={750}
          width={500}
          sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
          priority
        /&gt;
      &lt;/div&gt;
      &lt;div className=&#34;description relative w-full&#34;&gt;
        &lt;Image
          className=&#34;block z-0 object-cover brightness-50&#34;
          alt={movie.title}
          src={backdropPathUrl}
          fill
          priority
        /&gt;
        &lt;div className=&#34;relative flex flex-col&#34;&gt;
          &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
            &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
            &lt;div className=&#34;flex gap-2&#34;&gt;
              {movie.genres.map((genre) =&gt; {
                return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
              })}
            &lt;/div&gt;
            &lt;p&gt;{movie.tagline}&lt;/p&gt;
            &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
            &lt;div className=&#34;flex items-center gap-3&#34;&gt;
              &lt;Note note={movie.vote_average} /&gt;
              &lt;Like id={movie.id} /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

export default RSCMovieDetailsPage;
</code></pre>
<h2 is-upgraded>Affichage des critiques de films</h2>
<p>Afin de tirer partie de la force des React Server Components, nous allons afficher les critiques du film sur la page de détail. Nous allons :</p>
<ul>
<li>Mettre en cache la requête de récupération du film (7 jours)</li>
<li>Ne pas mettre de cache sur la requête de récupération des critiques</li>
<li>Garder nos composants client</li>
</ul>
<p>Dans le répertoire <code>/src/services</code> du projet, modifions le fichier <code>movie.service.tsx</code>.</p>
<p>Commençons par la méthode <code>getMovieDetails</code> en ajoutant <code>next: { revalidate: 604800 }</code></p>
<pre><code language="language-tsx" class="language-tsx">const getMovieDetails = async (movieId: number): Promise&lt;Movie&gt; =&gt; {
  const queryParams = new URLSearchParams();
  queryParams.append(QUERY_PARAMS.LANGUAGE, DEFAULT_PARAMS.LANGUAGE);

  const URL = `${
    process.env.NEXT_PUBLIC_API_URL
  }/movie/${movieId}?${queryParams.toString()}`;

  const result = await fetch(`${URL}`, {
    headers: API_HEADER,
    next: { revalidate: 604800 }, // 7 days
  });
  if (!result.ok) {
    throw new Error(&#39;Failed to fetch trending movies data&#39;);
  }

  return result.json();
};
</code></pre>
<p>Et la méthode <code>getMovieReviews</code> en ajoutant <code>cache: 'no-store'</code></p>
<pre><code language="language-tsx" class="language-tsx">const getMovieReviews = async (movieId: number): Promise&lt;Review[]&gt; =&gt; {
  const URL = `${process.env.NEXT_PUBLIC_API_URL}/movie/${movieId}/reviews`;

  const result = await fetch(`${URL}`, {
    headers: API_HEADER,
    cache: &#39;no-store&#39;,
  });

  if (!result.ok) {
    throw new Error(&#39;Failed to get movie reviews&#39;);
  }

  const data: ReviewResponse = await result.json();
  const reviews = data.results.slice(0, 3);

  return reviews;
};
</code></pre>
<p>Maintenant, nous pouvons rajouter la gestion des critiques sur notre page de détail :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import MovieReview from &#39;@/components/movie/review/MovieReview&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Review } from &#39;@/interfaces/review.interface&#39;;
import { getMovieDetails, getMovieReviews } from &#39;@/services/movie.service&#39;;
import Image from &#39;next/image&#39;;

const RSCMovieDetailsPage = async ({ params }: { params: { id: number } }) =&gt; {
  const [movie, reviews] = await Promise.all([
    getMovieDetails(params.id),
    getMovieReviews(params.id),
  ]);

  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    // ...
    &lt;div className=&#34;relative flex flex-col&#34;&gt;
      &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
        {/*  ...  */}
      &lt;/div&gt;
      &lt;div className=&#34;grid lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6 p-4&#34;&gt;
        {reviews.map((review: Review) =&gt; (
          &lt;MovieReview key={review.id} review={review} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
    // ...
  );
};

export default RSCMovieDetailsPage;
</code></pre>
<h2 is-upgraded>Observons ce qui se passe</h2>
<p>Ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
