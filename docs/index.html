
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Rendu front, action ! Découvrez les différents modes de rendu avec Next.js</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="docs"
                  title="Rendu front, action ! Découvrez les différents modes de rendu avec Next.js"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Initialisation du codelab" duration="5">
        <p>Prérequis :</p>
<ul>
<li><a href="https://git-scm.com/" target="_blank">Git</a></li>
<li><a href="https://nodejs.org/" target="_blank">Node / npm</a> (version 18 minimum)</li>
<li><a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> (ou tout autre IDE JS)</li>
</ul>
<aside class="warning"><p>Il est impératif d&#39;avoir une version 18 minimale de Node.js car elle est un prérequis pour les React Server Components que nous verrons dans ce codelab.</p>
</aside>
<p>Pour ce codelab nous utiliserons deux repositories :</p>
<ul>
<li>Le premier servira pour l&#39;exercice sur le client side rendering</li>
<li>L&#39;autre servira pour les exercices suivants, basés sur Next.js</li>
</ul>
<p>Clonons le projet pour l&#39;exercice sur le client side rendering, en se positionnant sur la branche <code>start</code> :</p>
<pre><code language="language-bash" class="language-bash">git clone --branch start https://github.com/Codelab-DevFest-2023/codelab-devfest2023-csr.git
cd codelab-devfest2023-csr
npm install
</code></pre>
<p>Lançons la commande <code>npm run dev</code> et vérifions qu&#39;on a bien une application qui s&#39;affiche sur l&#39;url <code>http://localhost:5173</code>.</p>
<p>Puis installons le projet pour les exercices avec Next.js :</p>
<pre><code language="language-bash" class="language-bash">git clone --branch start https://github.com/Codelab-DevFest-2023/codelab-devfest2023-next.git
cd codelab-devfest2023-next
npm install
</code></pre>
<p>Lançons la commande <code>npm run dev</code> et vérifons qu&#39;on a bien une application qui s&#39;affiche sur l&#39;url <code>http://localhost:3000</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Client Side Rendering" duration="20">
        <p>Dans cette première partie, nous allons développer une application en Client Side Rendering (CSR) s&#39;appuyant sur Vite.js, React et Tailwind. Nous n&#39;utiliserons donc pas Next.js dans cet exercice. Mais en créant une application en CSR, nous verrons mieux les différences avec les autres modes de rendu que nous verrons plus tard.</p>
<p>Pour cette partie nous travaillerons dans le répertoire <code>codelab-devfest2023-csr</code>.</p>
<aside class="special"><p>Pour se concentrer sur ce qui est spécifique au client side rendering, certains éléments sont déjà fournis dans le repository : carte d&#39;un film, méthodes de fetch des données, composant de layout, etc...</p>
</aside>
<h2 is-upgraded>Création des variables d&#39;environnement</h2>
<p>Pour pouvoir utiliser l&#39;API TMDB nous devons fournir une clé d&#39;API dans un fichier <code>.env</code>. Créons un fichier <code>.env</code> à la racine du projet avec le contenu suivant :</p>
<pre><code>VITE_API_URL=https://api.themoviedb.org/3
VITE_API_KEY=eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZmMxMDQ0YjI0ZDdkYjcyY2RlZmJmNTBkNTkyNzhiYyIsInN1YiI6IjY0YzU2ZTgyNjNhNjk1MDEwMzk5Y2I0YiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.Rc42SZEbnqH6PvJRj1GAVYTADLcR5vNzArE1P333_dI
</code></pre>
<p>Utilisons une clé d&#39;API parmi celles-ci :</p>
<p>Clé 1 :</p>
<pre><code>eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZmMxMDQ0YjI0ZDdkYjcyY2RlZmJmNTBkNTkyNzhiYyIsInN1YiI6IjY0YzU2ZTgyNjNhNjk1MDEwMzk5Y2I0YiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.Rc42SZEbnqH6PvJRj1GAVYTADLcR5vNzArE1P333_dI
</code></pre>
<p>Clé 2 :</p>
<pre><code>eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZmMxMDQ0YjI0ZDdkYjcyY2RlZmJmNTBkNTkyNzhiYyIsInN1YiI6IjY0YzU2ZTgyNjNhNjk1MDEwMzk5Y2I0YiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.Rc42SZEbnqH6PvJRj1GAVYTADLcR5vNzArE1P333_dI
</code></pre>
<p>TODO Ajouter d&#39;autres clés</p>
<h2 is-upgraded>Liste des 20 films les plus populaires</h2>
<p>Pour commencer, nous allons créer une page affichant la liste des 20 films les plus populaires du moment. Nous avons donc besoin de créer :</p>
<ul>
<li>Un hook <code>useMovies</code> qui permet de charger la liste des films</li>
<li>Un composant <code>MoviesListPage</code> qui correspond à la page affichant la liste des films</li>
<li>Une route <code>/movies</code> associée au composant <code>MoviesListPage</code></li>
</ul>
<p>Créons le fichier <code>/src/hooks/movies.ts</code> et ajoutons y le hook <code>useMovies</code>. Ce hook s&#39;appuie sur la librairie React Query pour charger la liste des films et gérer du cache. Elle s&#39;appuie sur un service de fetch qui appelle l&#39;API TMDB.</p>
<pre><code language="language-ts" class="language-ts">import { useQuery } from &#39;@tanstack/react-query&#39;;
import { AxiosError } from &#39;axios&#39;;
import { Movie } from &#39;../interfaces/movie.interface&#39;;
import { getMovies } from &#39;../services/movie.service&#39;;

const useMovies = () =&gt; {
  return useQuery&lt;Movie[], AxiosError&gt;({
    queryKey: [&#39;movies&#39;],
    queryFn: () =&gt; getMovies(),
  });
};

export { useMovies };
</code></pre>
<p>Puis modifions le composant <code>MoviesListPage</code> dans le fichier <code>/src/pages/movies/MoviesListPage.tsx</code> :</p>
<ul>
<li>Appel du hook <code>useMovies</code> pour récupérer les films</li>
<li>Affichage de <code>Chargement ...</code> pendant le chargement des données</li>
<li>Affichage d&#39;un message d&#39;erreur et d&#39;un bouton <code>Réessayer</code></li>
<li>Affichage d&#39;une carte pour chaque film chargé</li>
<li>Affichage d&#39;un message dans le cas où on n&#39;a aucun film</li>
</ul>
<p>Le composant doit ressembler à ça :</p>
<pre><code language="language-ts" class="language-ts">import MovieCard from &#39;../../components/movie/card/MovieCard&#39;;
import { useMovies } from &#39;../../hooks/movies&#39;;

const MoviesListPage = () =&gt; {
  const { data: movies, isFetching, isError, isFetched, refetch } = useMovies();
  return (
    &lt;div className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
      {isError &amp;&amp; (
        &lt;div&gt;
          &lt;p className=&#34;text-red mb-4&#34;&gt;
            Erreur lors de la récupération des films ...
          &lt;/p&gt;
          &lt;button
            type=&#34;button&#34;
            onClick={() =&gt; {
              refetch();
            }}
          &gt;
            Réessayer
          &lt;/button&gt;
        &lt;/div&gt;
      )}
      {isFetching &amp;&amp; &lt;p&gt;Chargement...&lt;/p&gt;}
      {
        isFetched &amp;&amp; movies &amp;&amp; movies?.length &gt; 0 &amp;&amp; (
        &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
          {movies.map((movie) =&gt; (
            &lt;li key={movie.id}&gt;
              &lt;MovieCard movie={movie} /&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
      {isFetched &amp;&amp; movies &amp;&amp; movies.length &lt; 1 &amp;&amp; (
        &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
};

export default MoviesListPage;
</code></pre>
<p>Enfin nous allons ajouter une route <code>/movies</code> dans le fichier <code>/src/App.tsx</code> et l&#39;associer au composant <code>MoviesListPage</code> comme ci-dessous.</p>
<pre><code language="language-ts" class="language-ts">import { BrowserRouter, Route, Routes } from &#39;react-router-dom&#39;;
import Layout from &#39;./components/layout/Layout&#39;;
import HomePage from &#39;./pages/home/HomePage&#39;;
import MoviesListPage from &#39;./pages/movies/MoviesListPage&#39;;

const App = () =&gt; {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&#34;/&#34; element={&lt;Layout /&gt;}&gt;
          &lt;Route index element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path=&#34;movies&#34; element={&lt;MoviesListPage /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};

export default App;
</code></pre>
<p>Il ne reste plus qu&#39;à rajouter un accès vers notre nouvelle route dans le fichier <code>/src/components/header/Header.tsx</code></p>
<pre><code language="language-ts" class="language-ts">// ...
          &lt;span className=&#34;hidden sm:block text-white font-semibold leading-6 xl:text-lg text-base&#34;&gt;
            Rendu front, action !
          &lt;/span&gt;
        &lt;/a&gt;

        &lt;ul className=&#34;text-white grid lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-4&#34;&gt;
          &lt;li&gt;
            &lt;Link
              to=&#34;/movies&#34;
              className=&#34;flex items-center gap-2 font-semibold leading-6 xl:text-lg text-base&#34;
            &gt;
              Liste des films
            &lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;img
          className=&#34;lg:block hidden&#34;
// ...
</code></pre>
<p>Démarrons l&#39;application en mode développement avec la commande <code>npm run dev</code>, ouvrons <code>http://localhost:5173</code>, cliquons sur le lien &#34;Liste des films&#34; dans le header et vérifions que la liste des films s&#39;affiche correctement.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite nous allons créer une page affichant le détail de chaque film. Nous avons besoin de créer :</p>
<ul>
<li>Un hook <code>useMovie</code> qui permet de charger le détail du film</li>
<li>Un composant <code>MovieDetailsPage</code> qui définit la page de détail d&#39;un film</li>
<li>Une route <code>/movies/:id</code> qui définit la route permettant d&#39;afficher le détail de chaque film</li>
</ul>
<p>Modifions le fichier <code>/src/hooks/movies.ts</code> pour ajouter un nouveau hook <code>useMovie</code> qui charge le détail d&#39;un film (toujours en s&#39;appuyant sur React Query) :</p>
<pre><code language="language-ts" class="language-ts">import { useQuery } from &#39;@tanstack/react-query&#39;;
import { AxiosError } from &#39;axios&#39;;
import { Movie } from &#39;../interfaces/movie.interface&#39;;
import { getMovieDetails, getMovies } from &#39;../services/movie.service&#39;;

// ...

const useMovie = (movieId: number) =&gt; {
  return useQuery&lt;Movie, AxiosError&gt;({
    queryKey: [&#39;movies&#39;, movieId],
    queryFn: () =&gt; getMovieDetails(movieId),
  });
};

export { useMovie, useMovies };
</code></pre>
<p>Puis modifions le fichier <code>/src/pages/movies/MovieDetailsPage.tsx</code> :</p>
<ul>
<li>Utilisation du hook <code>useMovie</code> pour récupérer le détail du film</li>
<li>Utilisation des statuts et méthodes retournés par React Query pour gérer un message de chargement et gérer les erreurs de chargement</li>
<li>Affichage des informations sur le film</li>
</ul>
<pre><code language="language-ts" class="language-ts">import { useParams } from &#39;react-router-dom&#39;;
import { useMovie } from &#39;../../hooks/movies&#39;;
import Like from &#39;../../components/like/Like&#39;;
import Note from &#39;../../components/note/Note&#39;;

const MovieDetailsPage = () =&gt; {
  const { movieId } = useParams();
  const {
    data: movie,
    isFetching,
    isError,
    isFetched,
    refetch,
  } = useMovie(Number(movieId));

  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie?.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie?.backdrop_path}`;

  return (
    &lt;div className=&#34;flex md:flex-row flex-col&#34;&gt;
      {isError &amp;&amp; (
        &lt;div&gt;
          &lt;p className=&#34;text-red mb-4&#34;&gt;
            Erreur lors de la récupération du film ...
          &lt;/p&gt;
          &lt;button type=&#34;button&#34; onClick={() =&gt; refetch()}&gt;
            Réessayer
          &lt;/button&gt;
        &lt;/div&gt;
      )}
      {isFetching &amp;&amp; &lt;p&gt;Chargement...&lt;/p&gt;}
      {isFetched &amp;&amp; movie &amp;&amp; (
        &lt;&gt;
          &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
            &lt;img
              src={posterUrl}
              alt={movie.title}
              className=&#34;aspect-[2/3] object-cover h-full&#34;
              height={750}
              width={500}
              sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
            /&gt;
          &lt;/div&gt;
          &lt;div className=&#34;description relative w-full&#34;&gt;
            &lt;img
              className=&#34;absolute z-0 object-cover h-full w-[inherit] brightness-50&#34;
              alt={movie.title}
              src={backdropPathUrl}
            /&gt;
            &lt;div className=&#34;relative flex flex-col&#34;&gt;
              &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
                &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
                &lt;div className=&#34;flex gap-2&#34;&gt;
                  {movie.genres.map((genre) =&gt; {
                    return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
                  })}
                &lt;/div&gt;
                &lt;p&gt;{movie.tagline}&lt;/p&gt;
                &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
                &lt;div className=&#34;flex items-center gap-3&#34;&gt;
                  &lt;Note note={movie.vote_average} /&gt;
                  &lt;Like id={movie.id} /&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
};

export default MovieDetailsPage;
</code></pre>
<p>Créons une nouvelle route <code>/movies/:id</code> dans le fichier <code>/src/App.tsx</code>.</p>
<pre><code language="language-ts" class="language-ts">import { BrowserRouter, Route, Routes } from &#39;react-router-dom&#39;;
import Layout from &#39;./components/layout/Layout&#39;;
import HomePage from &#39;./pages/home/HomePage&#39;;
import MovieDetailsPage from &#39;./pages/movies/MovieDetailsPage&#39;;
import MoviesListPage from &#39;./pages/movies/MoviesListPage&#39;;

const App = () =&gt; {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&#34;/&#34; element={&lt;Layout /&gt;}&gt;
          &lt;Route index element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path=&#34;movies&#34; element={&lt;MoviesListPage /&gt;} /&gt;
          &lt;Route path=&#34;movies/:movieId&#34; element={&lt;MovieDetailsPage /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};

export default App;
</code></pre>
<p>Et modifions la liste des films (<code>src/pages/movies/MoviesListPage.tsx</code>) pour ajouter un lien vers la page de détail du film sur la carte <code>MovieCard</code>, en utilisant le composant <code>Link</code> de <code>react-router-dom</code>.</p>
<pre><code language="language-ts" class="language-ts">{movies.map((movie) =&gt; (
  &lt;li key={movie.id}&gt;
    &lt;Link to={`/movies/${movie.id}`}&gt;
      &lt;MovieCard movie={movie} /&gt;
    &lt;/Link&gt;
  &lt;/li&gt;
))}
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code>, ouvrir le browser sur <code>http://localhost:5173</code>, accéder à liste des films puis cliquer sur un film afin d&#39;accéder à la page de détail de chaque film.</p>
<h2 is-upgraded>Analysons cette application</h2>
<p>Pour analyser le comportement d&#39;une application client side rendering, nous allons créer une version de production de l&#39;application avec la commande <code>npm run build</code> puis la lancer en mode preview avec la commande <code>npm run preview</code>.</p>
<p>Ouvrons l&#39;application sur <code>http://localhost:4173</code> puis ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>
<p>Enfin affichons le code source de la page pour constater que cette page n&#39;est pas très &#34;SEO friendly&#34; !</p>


      </google-codelab-step>
    
      <google-codelab-step label="Server Side Rendering" duration="35">
        <p>Dans cette deuxième partie, nous allons développer une application en Server Side Rendering s&#39;appuyant sur Next.js et Tailwind.</p>
<p>Pour cette partie et les suivantes nous travaillerons dans le répertoire <code>codelab-devfest2023-next</code>.</p>
<aside class="special"><p>Pour se concentrer sur ce qui est spécifique au server side rendering, certains composants vous sont déjà fournis dans le repository : carte d&#39;un film, méthodes de fetch, composant de layout, etc...</p>
</aside>
<aside class="warning"><p>Cet exercice utilisera le système de routage <strong>pages</strong> de Next.js.</p>
</aside>
<h2 is-upgraded>Création des variables d&#39;environnement</h2>
<p>Comme dans l&#39;exercice précédent nous avons besoin de fournir des variables d&#39;environnement pour fournir la clé API nécessaire à l&#39;utilisation de l&#39;API TMDB. Créons un fichier <code>.env</code> à la racine du projet avec le contenu suivant et remplaçons par la même clé API que celle utilisée lors de l&#39;exercice précédent :</p>
<pre><code>NEXT_PUBLIC_API_URL=https://api.themoviedb.org/3
NEXT_PUBLIC_API_KEY=eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIxNTk0NTM5OGIxMzZhODZhZDU4ZjE3MmFlYTQ3ZTNjZCIsInN1YiI6IjVlNzkxY2Y0MzU3YzAwMDAxMTU0MDAwZSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.8XGXQO22Mv8UaooWf0sDnUWRpNTdlzuO5rZClx-eEDc
</code></pre>
<h2 is-upgraded>Liste des films</h2>
<p>Nous allons créer une page affichant la liste des films.</p>
<p>Dans le répertoire <code>/src/pages/ssr</code> du projet, modifions le fichier <code>index.tsx</code>.</p>
<p>Nous allons définir une méthode <code>getServerSideProps</code> qui s&#39;exécute côté serveur lorsque la page est générée. Ici elle permet d&#39;appeler l&#39;API pour récupérer la liste des films et la passer en tant que props <code>movies</code> au composant <code>SSRPage</code>.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSRPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  // ...
};

export const getServerSideProps: GetServerSideProps&lt;{
  movies: Movie[];
}&gt; = async () =&gt; {
  const { results: movies } = await fetchMovies();
  return { props: { movies } };
};

export default SSRPage;
</code></pre>
<p>Il ne reste plus qu&#39;à finir de construire notre page, en parcourant la liste de films fournie par la props <code>movies</code> :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

const SSRPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Server Side Rendering&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
        &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
          {movies?.map((movie: Movie) =&gt; (
            &lt;li key={movie.id}&gt;
              &lt;MovieCard movie={movie} /&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        {movies.length &lt; 1 &amp;&amp; (
          &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
        )}
      &lt;/main&gt;
    &lt;/&gt;
  );
};

// ...
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/ssr</code>.</p>
<h2 is-upgraded>Optimisations des images</h2>
<p>Afin d&#39;optimiser l&#39;affichage des images sur l&#39;application, nous allons utiliser le composant <code>Image</code> de Next.js.</p>
<p>Ce composant intègre des optimisations sur la gestion des images pour améliorer l&#39;expérience utilisateur et l&#39;expérience développeir : chargement en mode lazy, chargement prioritaire, gestion du responsive, etc...</p>
<p>Dans le répertoire <code>/src/components/movie/card</code> du projet, ouvrons le composant <code>MovieCard</code>.</p>
<p>Remplaçons le composant <code>img</code> par un composant <code>Image</code> :</p>
<pre><code language="language-tsx" class="language-tsx">import Image from &#39;next/image&#39;;

// ...

&lt;Image
  src={posterUrl}
  alt={movie.title}
  className=&#34;rounded-t-lg aspect-[2/3] object-cover&#34;
  height={750}
  width={500}
  sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
/&gt;;

// ...
</code></pre>
<h2 is-upgraded>Recherche de films</h2>
<p>Nous allons créer un composant qui affiche un champ de recherche de films. Le terme recherché sera ajouté en tant que paramètre <code>query</code> dans l&#39;url de la page : <code>http://localhost:3000/ssr?query=xxxx</code>.</p>
<p>Le composant <code>SearchBox</code> est déjà fourni dans le fichier <code>/src/components/search/SearchBox.tsx</code>. Lors d&#39;une recherche ce composant rappelle la route courante en passant le paramètre <code>query</code> dans l&#39;url, en utilisant les hooks fournis par <code>next/navigation</code>. En tant que hooks ils s&#39;exécutent côté client uniquement.</p>
<pre><code language="language-tsx" class="language-tsx">import { QUERY_PARAMS } from &#39;@/constants&#39;;
import { usePathname, useRouter, useSearchParams } from &#39;next/navigation&#39;;
import { ChangeEvent, useState } from &#39;react&#39;;

const SearchBox = () =&gt; {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const [searchValue, setSearchValue] = useState&lt;string | undefined&gt;();

  const handleSearchChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const currentPathname = pathname ?? &#39;/&#39;;
    const value = event.target.value;
    setSearchValue(value);

    const queryParams = new URLSearchParams();
    queryParams.append(QUERY_PARAMS.QUERY, encodeURI(value));

    if (value.length &gt; 3) {
      router.push(`${currentPathname}?${queryParams.toString()}`);
    }

    if (value.length &lt;= 2 &amp;&amp; searchParams?.get(QUERY_PARAMS.QUERY)) {
      router.push(currentPathname);
    }
  };

  return (
    &lt;input
      type=&#34;text&#34;
      className=&#34;text-xl py-3 px-6 bg-white rounded-full w-fit focus-visible:ring-primary focus-visible:ring-offset-primary&#34;
      placeholder=&#34;Recherche ...&#34;
      value={searchValue}
      onChange={handleSearchChange}
    /&gt;
  );
};

export default SearchBox;
</code></pre>
<p>Ce paramètre <code>query</code> doit être récupéré côté serveur pour apper la bonne route d&#39;API TMDB :</p>
<ul>
<li>La route <code>search/movie</code> en cas de présence du paramètre <code>query</code></li>
<li>La route <code>movie/popular</code> en cas d&#39;absence du paramètre <code>query</code></li>
</ul>
<p>Modifions donc la méthode <code>getServerSideProps</code> de la page <code>/src/pages/ssr/index.tsx</code> afin de récupérer le paramètre <code>query</code> et le passer à la méthode <code>fetchMovies</code> :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { transformParsedUrlQuery } from &#39;@/helpers&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

// ...

export const getServerSideProps: GetServerSideProps&lt;{
  movies: Movie[];
}&gt; = async ({ query: params }) =&gt; {
  const searchParams = transformParsedUrlQuery(params);
  const { results: movies } = await fetchMovies(searchParams);
  return { props: { movies } };
};
</code></pre>
<p>Il ne reste plus qu&#39;a ajouter le composant <code>SearchBox</code> dans notre page <code>src/pages/ssr/index.tsx</code> :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import SearchBox from &#39;@/components/search/SearchBox&#39;;
import { transformParsedUrlQuery } from &#39;@/helpers&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;

// ...
&lt;&gt;
  &lt;Head&gt;
    &lt;title&gt;Server Side Rendering&lt;/title&gt;
  &lt;/Head&gt;
  &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
    &lt;SearchBox /&gt;
    &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
      {movies?.map((movie: Movie) =&gt; (
        &lt;li key={movie.id}&gt;
          &lt;MovieCard movie={movie} /&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
    {movies.length &lt; 1 &amp;&amp; (
      &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
    )}
  &lt;/main&gt;
&lt;/&gt;;
// ...
</code></pre>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Nous allons ensuite créer une page affichant le détail de chaque film.</p>
<p>Dans le répertoire <code>/src/pages/ssr</code> du projet, modifions le fichier <code>[id].tsx</code></p>
<p>Modifions la méthode <code>getServerSideProps</code> pour récupérer les données concernant le film passé en paramètre.</p>
<pre><code language="language-tsx" class="language-tsx">import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;

const SSRMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  // ...
};

export const getServerSideProps: GetServerSideProps&lt;{
  movie: Movie;
}&gt; = async ({ params }) =&gt; {
  if (params?.id) {
    const id = Number(params.id);
    const movie = await getMovieDetails(id);
    return { props: { movie } };
  } else {
    throw new Error(&#39;Missing id parameter&#39;);
  }
};

export default SSRMovieDetailsPage;
</code></pre>
<p>Il ne reste plus qu&#39;à finir de construire notre page, en affichant :</p>
<ul>
<li>L&#39;affiche du film</li>
<li>Le titre du film</li>
<li>Le synopsis du film</li>
<li>La note du film</li>
</ul>
<pre><code language="language-tsx" class="language-tsx">import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

const SSRMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;) =&gt; {
  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main&gt;
      &lt;Head&gt;
        &lt;title&gt;Server Side Rendering&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div className=&#34;flex md:flex-row flex-col&#34;&gt;
        &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
          &lt;Image
            src={posterUrl}
            alt={movie.title}
            className=&#34;aspect-[2/3] object-cover h-full&#34;
            height={750}
            width={500}
            sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
            priority
          /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;description relative w-full&#34;&gt;
          &lt;Image
            className=&#34;block z-0 object-cover brightness-50&#34;
            alt={movie.title}
            src={backdropPathUrl}
            fill
            priority
          /&gt;
          &lt;div className=&#34;relative flex flex-col&#34;&gt;
            &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
              &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
              &lt;div className=&#34;flex gap-2&#34;&gt;
                {movie.genres.map((genre) =&gt; {
                  return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
                })}
              &lt;/div&gt;
              &lt;p&gt;{movie.tagline}&lt;/p&gt;
              &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
              &lt;div className=&#34;flex items-center gap-3&#34;&gt;
                &lt;Note note={movie.vote_average} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

// ...
</code></pre>
<p>Et enfin modifions la liste des films (<code>src/pages/ssr/index.tsx</code>) pour ajouter un lien vers la page de détail du film sur la carte <code>MovieCard</code>, en utilisant le composant <code>Link</code> de <code>,next/link</code>.</p>
<pre><code language="language-ts" class="language-ts">{movies?.map((movie: Movie) =&gt; (
  &lt;li key={movie.id}&gt;
    &lt;Link href={`/ssr/${movie.id}`}&gt;
      &lt;MovieCard movie={movie} /&gt;
    &lt;/Link&gt;
  &lt;/li&gt;
))}
</code></pre>
<p>Vérifions dans l&#39;application qu&#39;on accède bien au détail d&#39;un film quand on clique sur sa vignette dans la liste des films.</p>
<h2 is-upgraded>Gestion de favoris</h2>
<p>Pour terminer nous allons mettre en place la possibilité de gérer des films favoris à travers un composant <code>Like</code> présent dans la page de détail qui permet d&#39;ajouter / enlever le film des favoris, stockés dans le local storage du navigateur. Le local storage n&#39;étant disponible que côté client, il faudra s&#39;assurer que notre code de gestion des favoris ne s&#39;exécute que côté client.</p>
<p>Dans le répertoire <code>/src/components/like</code> du projet, ouvrons le fichier <code>Like.tsx</code>.</p>
<pre><code language="language-tsx" class="language-tsx">&#39;use client&#39;;
import { useEffect, useState } from &#39;react&#39;;
import &#39;./like.module.css&#39;;

interface Props {
  id: number;
}

const Like = ({ id }: Props) =&gt; {
  const [filled, setFilled] = useState(false);

  useEffect(() =&gt; {
    const favorites = localStorage.getItem(&#39;favorites&#39;);
    if (favorites) {
      const isFind = JSON.parse(favorites).find(
        (element: { id: number }) =&gt; element.id === id
      );
      if (isFind) {
        setFilled(true);
      }
    } else {
      setFilled(false);
    }
  }, [id]);

  const handleClick = () =&gt; {
    const favorites = localStorage.getItem(&#39;favorites&#39;);
    if (favorites) {
      const favoritesList = JSON.parse(favorites);

      const filterFav = favoritesList.filter(
        (fav: { id: number }) =&gt; fav.id !== id
      );

      if (filterFav.length === favoritesList.length) {
        setFilled(true);
        favoritesList.push({ id: id });
        localStorage.setItem(&#39;favorites&#39;, JSON.stringify(favoritesList));
      } else {
        setFilled(false);
        localStorage.setItem(&#39;favorites&#39;, JSON.stringify(filterFav));
      }
    } else {
      setFilled(true);
      localStorage.setItem(&#39;favorites&#39;, JSON.stringify([{ id: id }]));
    }
  };

  return (
    &lt;button
      className={`heart-button ${filled ? &#39;filled&#39; : &#39;&#39;}`}
      onClick={handleClick}
    &gt;
      &lt;svg className=&#34;heart-icon&#34; viewBox=&#34;0 0 26 26&#34;&gt;
        &lt;path d=&#34;M12 21.35l-1.45-1.32C5.4 16.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C15.09 3.81 16.76 3 18.5 3 21.58 3 24 5.42 24 8.5c0 3.78-3.4 7.86-8.55 11.54L12 21.35z&#34; /&gt;
      &lt;/svg&gt;
    &lt;/button&gt;
  );
};

export default Like;
</code></pre>
<p>Il ne reste plus qu&#39;à rajouter ce nouveau composant dans la page SSR (<code>/src/pages/ssr/[id].tsx</code>) :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import { GetServerSideProps, InferGetServerSidePropsType } from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

// ...
&lt;div className=&#34;relative flex flex-col&#34;&gt;
  &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
    &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
    &lt;div className=&#34;flex gap-2&#34;&gt;
      {movie.genres.map((genre) =&gt; {
        return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
      })}
    &lt;/div&gt;
    &lt;p&gt;{movie.tagline}&lt;/p&gt;
    &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
    &lt;div className=&#34;flex items-center gap-3&#34;&gt;
      &lt;Note note={movie.vote_average} /&gt;
      &lt;Like id={movie.id} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;;
// ...
</code></pre>
<h2 is-upgraded>Observons ce qui se passe</h2>
<p>Construisons une version de production de l&#39;application avec la commande <code>npm run build</code> puis démarrons l&#39;application avec la commande <code>npm run start</code>.</p>
<p>Ouvrons l&#39;application sur <code>http://localhost:3000</code> puis accédons à la rubrique &#34;Server Side Rendering&#34; et observons ce qui se passe dans les devtools de Chrome (ou équivalent) :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Static Site Generation" duration="10">
        <aside class="special"><p>Si vous n&#39;avez pas eu le temps de finir l&#39;étape précédente, vous pouvez faire un checkout de la branche &#34;ssr-end&#34; pour débuter cette étape : <code>git checkout -f ssr-end</code></p>
</aside>
<p>Dans cette troisième partie, nous allons développer la même application que précédement mais en Static Site Generation en s&#39;appuyant sur Next.js et Tailwind.</p>
<aside class="warning"><p>Cet exercice utilisera le routage <strong>pages</strong> (Next.js &lt; 13).</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Comme dans l&#39;exercice précédent, nous aurons besoin de créer la page d&#39;affichage de la liste des films.</p>
<p>Dans le répertoire <code>/src/pages/ssg</code> du projet, modifions le fichier <code>index.tsx</code>.</p>
<p>Il sera très semblable au fichier <code>/src/pages/ssr</code>. La principale différence réside dans le remplacement de méthode  <code>getServerSideProps</code> par la méthode <code>getStaticProps</code>.</p>
<pre><code language="language-ts" class="language-ts">export const getStaticProps: GetStaticProps&lt;{
  movies: Movie[];
}&gt; = async () =&gt; {
  const { results: movies } = await getMovies();
  return { props: { movies } };
};
</code></pre>
<p>Le reste du fichier est très semblable à ce qui a été fait pour le server side rendering : on passe la liste des films dans la props <code>movies</code> du composant et on parcourt cette liste.</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovies } from &#39;@/services/movie.service&#39;;
import {
  GetServerSideProps,
  GetStaticProps,
  InferGetServerSidePropsType,
} from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Link from &#39;next/link&#39;;

const SSGPage = ({
  movies,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Static Site Generation&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
        &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
          {movies?.map((movie: Movie) =&gt; (
            &lt;li key={movie.id}&gt;
              &lt;Link href={`/ssg/${movie.id}`}&gt;
                &lt;MovieCard movie={movie} /&gt;
              &lt;/Link&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
        {movies.length &lt; 1 &amp;&amp; (
          &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
        )}
      &lt;/main&gt;
    &lt;/&gt;
  );
};

export const getStaticProps: GetStaticProps&lt;{
  movies: Movie[];
}&gt; = async () =&gt; {
  const { results: movies } = await getMovies();
  return { props: { movies } };
};

export default SSGPage;
</code></pre>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/ssg</code>.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite, nous allons créer les pages affichant le détail de chaque film. Là encore le code est très proche de ce qu&#39;on a en Server Side Rendering.</p>
<p>Modifions le fichier <code>/src/pages/ssg/[id].tsx</code> du projet et ajoutons la méthode <code>getStaticProps</code>.</p>
<pre><code language="language-ts" class="language-ts">export const getStaticProps: GetStaticProps&lt;{
  movie: Movie;
}&gt; = async ({ params = {} }) =&gt; {
  const id = Number(params.id);
  const movie = await getMovieDetails(id);
  return { props: { movie } };
};
</code></pre>
<p>Le reste du fichier est quasiment identique au server side rendering :</p>
<pre><code language="language-ts" class="language-ts">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { getMovieDetails, getMovies } from &#39;@/services/movie.service&#39;;
import {
  GetStaticProps,
  InferGetServerSidePropsType
} from &#39;next&#39;;
import Head from &#39;next/head&#39;;
import Image from &#39;next/image&#39;;

const SSGMovieDetailsPage = ({
  movie,
}: InferGetServerSidePropsType&lt;typeof getStaticProps&gt;) =&gt; {
  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main&gt;
      &lt;Head&gt;
        &lt;title&gt;Static Site Generation&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div className=&#34;flex md:flex-row flex-col&#34;&gt;
        &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
          &lt;Image
            src={posterUrl}
            alt={movie.title}
            className=&#34;aspect-[2/3] object-cover h-full&#34;
            height={750}
            width={500}
            sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
            priority
          /&gt;
        &lt;/div&gt;
        &lt;div className=&#34;description relative w-full&#34;&gt;
          &lt;Image
            className=&#34;block z-0 object-cover brightness-50&#34;
            alt={movie.title}
            src={backdropPathUrl}
            fill
            priority
          /&gt;
          &lt;div className=&#34;relative flex flex-col&#34;&gt;
            &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
              &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
              &lt;div className=&#34;flex gap-2&#34;&gt;
                {movie.genres.map((genre) =&gt; {
                  return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
                })}
              &lt;/div&gt;
              &lt;p&gt;{movie.tagline}&lt;/p&gt;
              &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
              &lt;div className=&#34;flex items-center gap-3&#34;&gt;
                &lt;Note note={movie.vote_average} /&gt;
                &lt;Like id={movie.id} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

export const getStaticProps: GetStaticProps&lt;{
  movie: Movie;
}&gt; = async ({ params = {} }) =&gt; {
  const id = Number(params.id);
  const movie = await getMovieDetails(id);
  return { props: { movie } };
};

export default SSGMovieDetailsPage;
</code></pre>
<p>Nous avons cependant besoin d&#39;ajouter une méthode supplémentaire dans ce fichier : la méthode <code>getStaticPaths</code> retourne la liste des URLs des pages de détail à créer en s&#39;appuyant sur la liste des films.</p>
<pre><code language="language-ts" class="language-ts">import {
  GetStaticPaths,
  GetStaticProps,
  InferGetServerSidePropsType
} from &#39;next&#39;;

// ...

export const getStaticPaths: GetStaticPaths = async () =&gt; {
  const { results: movies } = await getMovies();
  return {
    paths: movies.map((movie) =&gt; `/ssg/${movie.id}`),
    fallback: false,
  };
};
</code></pre>
<aside class="special"><p>On voit ici que vu qu&#39;on génère une page pour chaque film, le build de l&#39;application en mode Static Site Generation peut être long si on s&#39;intéresse à l&#39;ensemble des films de la base TMDB ! C&#39;est pour cette raison que dans cet exercice on s&#39;est intéressés uniquement aux films populaires du moment.</p>
</aside>
<h2 is-upgraded>Observons ce qui se passe ...</h2>
<p>Pour réellement comprendre le fonctionnement du Static Site Generation, il faut lancer le build du site avec la commande <code>npm run build</code>. Observons alors que des requêtes sont envoyées à l&#39;API TMDB pour construire des pages statiques.</p>
<p>Exécutons ensuite la commande <code>npm run start</code> pour lancer l&#39;application. Le résultat pour l&#39;utilisateur est rigoureusement identique.</p>


      </google-codelab-step>
    
      <google-codelab-step label="React Server Components" duration="25">
        <p>TODO On devrait avoir des problèmes car pas de &#34;use client&#34;</p>
<aside class="special"><p>Si vous n&#39;avez pas eu le temps de finir l&#39;étape précédente, vous pouvez faire un checkout de la branche &#34;ssg-end&#34; pour débuter cette étape : <code>git checkout -f ssg-end</code></p>
</aside>
<p>Dans cette quatrième et dernière partie, nous allons développer la même application que précédement mais en utilisant les React Server Components, toujours en s&#39;appuyant sur Next.js et Tailwind.</p>
<aside class="warning"><p>Cet exercice utilisera le routage <strong>app</strong> (Next.js &gt; 13).</p>
</aside>
<h2 is-upgraded>Liste des films</h2>
<p>Comme dans l&#39;exercice précédent, nous aurons besoin de créer la page d&#39;affichage de la liste des films.</p>
<p>Dans le répertoire <code>/src/app/rsc</code> du projet, modifions le fichier <code>page.tsx</code>.</p>
<p>Nous n&#39;avons plus besoin d&#39;utiliser une méthode spécifique pour récupérer les données. nous pouvons directement faire un appel API dans notre composant serveur :</p>
<pre><code language="language-tsx" class="language-tsx">import MovieCard from &#39;@/components/movie/card/MovieCard&#39;;
import SearchBox from &#39;@/components/search/SearchBox&#39;;
import { Movie } from &#39;@/interfaces/movie.interface&#39;;
import { fetchMovies } from &#39;@/services/movie.service&#39;;

export const revalidate = 0;

interface Props {
  searchParams: { [key: string]: string | string[] | undefined };
}

const RSCPage = async ({ searchParams }: Props) =&gt; {
  const pathname = &#39;/rsc&#39;;
  const { results: movies } = await fetchMovies(searchParams);

  return (
    &lt;main className=&#34;lg:mx-44 mx-4 space-y-4 lg:pt-6 pt-14 pb-20&#34;&gt;
      &lt;SearchBox /&gt;
      &lt;ul className=&#34;movies-list grid xl:grid-cols-4 lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6&#34;&gt;
        {movies?.map((movie: Movie) =&gt; (
          &lt;li key={movie.id}&gt;
            &lt;MovieCard movie={movie} pathname={pathname} /&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      {movies.length &lt; 1 &amp;&amp; (
        &lt;p className=&#34;font-medium text-3xl&#34;&gt;Aucun résultat&lt;/p&gt;
      )}
    &lt;/main&gt;
  );
};

export default RSCPage;
</code></pre>
<aside class="special"><p>Le code <strong>export const revalidate = 0;</strong> est un mécanisme qui permet de mettre en cache les données générées côté serveur (SSR) pendant une période spécifiée. En mettant revalidate à zéro (0), cela signifie que les données seront générées à chaque demande sans mise en cache ni expiration. </p>
</aside>
<p>Nous pouvons démarrer l&#39;application avec la commande <code>npm run dev</code> et constater que la liste des films s&#39;affiche correctement à l&#39;adresse <code>http://localhost:3000/rsc</code>.</p>
<h2 is-upgraded>Détail d&#39;un film</h2>
<p>Ensuite, nous allons créer un écran affichant le détail de chaque film.</p>
<p>Dans le répertoire <code>/src/app/rsc/[id]</code> du projet, modifions le fichier <code>page.tsx</code>.</p>
<p>Comme précédement, nous pouvons directement faire un appel API dans notre composant serveur :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { getMovieDetails } from &#39;@/services/movie.service&#39;;
import Image from &#39;next/image&#39;;

const RSCMovieDetailsPage = async ({ params }: { params: { id: number } }) =&gt; {
  const movie = await getMovieDetails(params.id);

  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    &lt;main className=&#34;flex md:flex-row flex-col&#34;&gt;
      &lt;div className=&#34;poster z-10 md:order-first order-last&#34;&gt;
        &lt;Image
          src={posterUrl}
          alt={movie.title}
          className=&#34;aspect-[2/3] object-cover h-full&#34;
          height={750}
          width={500}
          sizes=&#34;(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw&#34;
          priority
        /&gt;
      &lt;/div&gt;
      &lt;div className=&#34;description relative w-full&#34;&gt;
        &lt;Image
          className=&#34;block z-0 object-cover brightness-50&#34;
          alt={movie.title}
          src={backdropPathUrl}
          fill
          priority
        /&gt;
        &lt;div className=&#34;relative flex flex-col&#34;&gt;
          &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
            &lt;h1 className=&#34;text-xl font-semibold&#34;&gt;{movie.title}&lt;/h1&gt;
            &lt;div className=&#34;flex gap-2&#34;&gt;
              {movie.genres.map((genre) =&gt; {
                return &lt;p key={genre.id}&gt;{genre.name}&lt;/p&gt;;
              })}
            &lt;/div&gt;
            &lt;p&gt;{movie.tagline}&lt;/p&gt;
            &lt;p className=&#34;mt-2 mr-10&#34;&gt;{movie.overview}&lt;/p&gt;
            &lt;div className=&#34;flex items-center gap-3&#34;&gt;
              &lt;Note note={movie.vote_average} /&gt;
              &lt;Like id={movie.id} /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  );
};

export default RSCMovieDetailsPage;
</code></pre>
<h2 is-upgraded>Affichage des critiques de films</h2>
<p>Afin de tirer partie de la force des React Server Components, nous allons afficher les critiques du film sur la page de détail. Nous allons :</p>
<ul>
<li>Mettre en cache la requête de récupération du film (7 jours)</li>
<li>Ne pas mettre de cache sur la requête de récupération des critiques</li>
<li>Garder nos composants client</li>
</ul>
<p>Dans le répertoire <code>/src/services</code> du projet, modifions le fichier <code>movie.service.tsx</code>.</p>
<p>Commençons par la méthode <code>getMovieDetails</code> en ajoutant <code>next: { revalidate: 604800 }</code></p>
<pre><code language="language-tsx" class="language-tsx">const getMovieDetails = async (movieId: number): Promise&lt;Movie&gt; =&gt; {
  const queryParams = new URLSearchParams();
  queryParams.append(QUERY_PARAMS.LANGUAGE, DEFAULT_PARAMS.LANGUAGE);

  const URL = `${
    process.env.NEXT_PUBLIC_API_URL
  }/movie/${movieId}?${queryParams.toString()}`;

  const result = await fetch(`${URL}`, {
    headers: API_HEADER,
    next: { revalidate: 604800 }, // 7 days
  });
  if (!result.ok) {
    throw new Error(&#39;Failed to fetch trending movies data&#39;);
  }

  return result.json();
};
</code></pre>
<p>Et la méthode <code>getMovieReviews</code> en ajoutant <code>cache: 'no-store'</code></p>
<pre><code language="language-tsx" class="language-tsx">const getMovieReviews = async (movieId: number): Promise&lt;Review[]&gt; =&gt; {
  const URL = `${process.env.NEXT_PUBLIC_API_URL}/movie/${movieId}/reviews`;

  const result = await fetch(`${URL}`, {
    headers: API_HEADER,
    cache: &#39;no-store&#39;,
  });

  if (!result.ok) {
    throw new Error(&#39;Failed to get movie reviews&#39;);
  }

  const data: ReviewResponse = await result.json();
  const reviews = data.results.slice(0, 3);

  return reviews;
};
</code></pre>
<p>Maintenant, nous pouvons rajouter la gestion des critiques sur notre page de détail :</p>
<pre><code language="language-tsx" class="language-tsx">import Like from &#39;@/components/like/Like&#39;;
import MovieReview from &#39;@/components/movie/review/MovieReview&#39;;
import Note from &#39;@/components/note/Note&#39;;
import { Review } from &#39;@/interfaces/review.interface&#39;;
import { getMovieDetails, getMovieReviews } from &#39;@/services/movie.service&#39;;
import Image from &#39;next/image&#39;;

const RSCMovieDetailsPage = async ({ params }: { params: { id: number } }) =&gt; {
  const [movie, reviews] = await Promise.all([
    getMovieDetails(params.id),
    getMovieReviews(params.id),
  ]);

  const posterUrl = `https://image.tmdb.org/t/p/w500/${movie.poster_path}`;
  const backdropPathUrl = `https://image.tmdb.org/t/p/original/${movie.backdrop_path}`;

  return (
    // ...
    &lt;div className=&#34;relative flex flex-col&#34;&gt;
      &lt;div className=&#34;flex flex-col gap-3 ml-4 text-white mt-3&#34;&gt;
        {/*  ...  */}
      &lt;/div&gt;
      &lt;div className=&#34;grid lg:grid-cols-3 sm:grid-cols-2 grid-cols-1 gap-6 p-4&#34;&gt;
        {reviews.map((review: Review) =&gt; (
          &lt;MovieReview key={review.id} review={review} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
    // ...
  );
};

export default RSCMovieDetailsPage;
</code></pre>
<h2 is-upgraded>Observons ce qui se passe</h2>
<p>Ouvrons les devtools de Chrome (ou équivalent) pour observer :</p>
<ul>
<li>Les chargements de fichiers Javascript</li>
<li>Les appels de service REST</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
